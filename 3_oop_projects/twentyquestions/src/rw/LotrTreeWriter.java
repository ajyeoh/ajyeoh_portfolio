package rw;

import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import binTree.BinaryTree;
import binTree.BinaryTreeNode;

/**
 * LotrTreeWriter.java
 * 
 * Modified from sample code.
 * 
 * @author adelyn.yeoh
 *
 */
public class LotrTreeWriter {
	/**
	 * Writes expression binary tree object to file.
	 * 
	 * @param tree
	 *            BinaryTree<String>
	 * @param file
	 *            String
	 * @return boolean
	 */
	public static boolean writeExpr(BinaryTree<String> tree, String file) {
		return writeExpr(tree, new File(file));
	}

	/**
	 * Writes BodyAndBarStructure object to file.
	 * 
	 * @param tree
	 *            BinaryTree<String>
	 * @param file
	 *            File
	 * @return boolean
	 */
	public static boolean writeExpr(BinaryTree<String> tree, File file) {

		// obtain default parser
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

		try {
			// get DocumentBuilder
			DocumentBuilder builder = factory.newDocumentBuilder();

			Document document = builder.newDocument();

			// create root node
			Element root = createBinTreeElement(tree, document);

			// add root node to document
			document.appendChild(root);

			// write document
			output(document, new StreamResult(file));

			return true;

		} catch (ParserConfigurationException pce) {
			pce.printStackTrace();
		}
		return false;
	}

	/**
	 * outputs document.
	 * 
	 * @param document
	 *            Document
	 * @param result
	 *            StreamResult
	 **/
	private static void output(Document document, StreamResult result) {
		try {
			// Use a Transformer for output
			TransformerFactory tFactory = TransformerFactory.newInstance();
			Transformer transformer = tFactory.newTransformer();

			DOMSource source = new DOMSource(document);
			transformer.transform(source, result);
		} catch (TransformerConfigurationException tce) {
			// Error generated by the parser
			System.out.println("\n** Transformer Factory error");
			System.out.println("   " + tce.getMessage());

			// Use the contained exception, if any
			Throwable x = tce;
			if (tce.getException() != null)
				x = tce.getException();
			x.printStackTrace();
		} catch (TransformerException te) {
			// Error generated by the parser
			System.out.println("\n** Transformation error");
			System.out.println("   " + te.getMessage());

			// Use the contained exception, if any
			Throwable x = te;
			if (te.getException() != null)
				x = te.getException();
			x.printStackTrace();
		}
	}

	/**
	 * creates expression element corresponding to tree.
	 * 
	 * @param tree
	 *            BinaryTree<String>
	 * @param document
	 *            Document
	 * @return Element for struct.
	 **/
	private static Element createBinTreeElement(BinaryTree<String> tree,
			Document document) {
		// create element with tag name expr
		return createExprNodeElement(tree.getRoot(), document);
	}

	/**
	 * creates element corresponding to expression node.
	 * 
	 * @param node
	 *            BinaryTree<String>
	 * @param document
	 *            Document
	 * @return Element for node.
	 **/
	private static Element createExprNodeElement(BinaryTreeNode<String> node,
			Document document) {
		Element nodeElt = document.createElement("expr");

		// base case
		if (node.isLeaf()) {

			nodeElt.setAttribute("type", "answer");

			// create atom node
			Element atomElt = document.createElement("answer");

			// set value
			atomElt.setAttribute("value", node.getData().toString());

			// add as only child
			nodeElt.appendChild(atomElt);
		}
		// recursive case
		else {
			nodeElt.setAttribute("type", "question");

			// create question node
			Element questionElt = document.createElement("qn");

			// set value
			questionElt.setAttribute("value", node.getData().toString());

			// add as child
			nodeElt.appendChild(questionElt);

			// recursively add questions
			// NOTE: order is *not* preserved
			if (node.getLeftChild() != null)
				nodeElt.appendChild(createExprNodeElement(node.getLeftChild(),
						document));
			if (node.getRightChild() != null)
				nodeElt.appendChild(createExprNodeElement(node.getRightChild(),
						document));
		}
		return nodeElt;
	}
}
